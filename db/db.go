package db

import (
	"database/sql"
	"fmt"
	_ "github.com/lib/pq"
	"log"
	"os"
)

type Database struct {
	db *sql.DB
}

// Public

// поправить connStr
func New() *Database {
	psqlInfo := fmt.Sprintf("host=%s port=%d user=%s "+
		"password=%s dbname=%s sslmode=disable",
		"db", 5432, "postgres-dev", "user", "dev")
	connStr := "user=" + os.Getenv("POSTGRES_USER") + " password=" + os.Getenv("POSTGRES_PASSWORD")
	connStr += " dbname=" + os.Getenv("POSTGRES_DB")
	db, err := sql.Open("postgres", psqlInfo)
	if err != nil {
		log.Fatal(err)
	}
	return &Database{
		db,
	}
}

func (d Database) Initialize(timezones []string) {
	err := d.db.Ping()
	if err != nil {
		log.Fatal(err)
	}
	d.dropTables()
	d.createTUsers()
	d.createTTimezones(timezones)
	d.createTUserData()
}

// протестировать
func (d Database) GetTimezones(userID int) []string {
	query := "select timezone from timezones where id = $1"
	rows, err := d.db.Query(query, userID)
	if err != nil {
		log.Printf("db gettimezones: %v", err)
		return nil
	}
	defer rows.Close()

	result := make([]string, 0)
	for rows.Next() {
		var timezone string
		if err := rows.Scan(&timezone); err != nil {
			log.Printf("db gettimezones: %v", err)
			return nil
		}
		result = append(result, timezone)
	}
	return result
}

func (d Database) CreateUser(id int) bool {
	query := "select * from users where id = $1"
	row := d.db.QueryRow(query, id)
	var tmp int
	if err := row.Scan(&tmp); err == sql.ErrNoRows {
		fmt.Println(err)
		query = "insert into users(id) values ($1)"
		_, err := d.db.Exec(query, id)
		if err != nil {
			log.Println(err)
		}
		return true
	}
	fmt.Println("уже есть")
	return false
}

// Исправить т.к timezone_id != string
func (d Database) UpdateUserData(id int, timezones []string){
	ext := d.CreateUser(id)
	fmt.Printf("МЫ были ТУТ")
	if ext {
		query := "insert into user_data (user_id, timezone_id) values ($1, $2)"
		for i := 0; i < len(timezones); i++ {
			_, err := d.db.Exec(query, id, timezones[i])
			if err != nil {
				log.Printf("db updateuserdata: %v", err)
			}
		}
	} else {
		tmpSlice := d.GetTimezones(id)


		union := make(map[string]bool)
		for _, str := range tmpSlice {
			union[str] = true
		}
		for _, str := range timezones {
			union[str] = true
		}

		query := "insert into user_data (user_id, timezone_id) values ($1, $2)"
		for k := range union{
			_, err := d.db.Exec(query, id, k)
			if err != nil {
				log.Printf("db updateuserdata: %v", err)
			}
		}
	}
}

func (d Database) Close() {
	err := d.db.Close()
	if err != nil {
		log.Printf("db close: %v", err)
	}
}

// Private
func (d Database) dropTables(){
	query := "drop table if exists %s"
	tables := []string{
		"user_data",
		"users",
		"timezones",
	}
	for i := 0; i < len(tables); i++ {
		_, err := d.db.Exec(fmt.Sprintf(query, tables[i]))
		if err != nil {
			log.Fatal(err)
		}
	}
}

func (d Database) createTUsers() {
	// Создание таблиц
	// Таблица users
	query := `create table users(
  				id integer PRIMARY KEY,
  				timestamp timestamp default current_timestamp
			 );`
	_, err := d.db.Exec(query)
	if err != nil {
		log.Fatal(err)
	}
}

func (d Database) createTTimezones(timezones []string) {
	// Таблица timezones
	query := `create table timezones(
  				id integer generated by default as identity PRIMARY KEY,
  				timezone VARCHAR(30) NOT NULL UNIQUE
			 );`
	_, err := d.db.Exec(query)
	if err != nil {
		log.Fatal(err)
	}
	// инициализация timezones
	query = "insert into timezones (timezone) values ($1)"
	for i := 0; i < len(timezones); i++ {
		_, err = d.db.Exec(query, timezones[i])
	}
}

func (d Database) createTUserData() {
	// таблица user_data
	query := `create table user_data(
  				user_id integer,
  				timezone_id integer,
  				timestamp timestamp default current_timestamp,
 				PRIMARY KEY(user_id, timezone_id),
  				FOREIGN KEY (user_id) references users(id),
  				FOREIGN KEY (timezone_id) REFERENCES timezones(id)
			  );`
	_, err := d.db.Exec(query)
	if err != nil {
		log.Fatal(err)
	}
}

